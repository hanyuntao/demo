<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>小游戏之俄罗斯方块</title>
	<script src="jquery/jquery-1.9.1.min.js"></script>
	<style type="text/css">
		table {
			border: 1px solid black;
		}
		td {
			width: 20px;
			height: 20px;
			border: 1px solid black;
		}
	</style>
</head>
<body>
	<div id = "game-box"></div>
	<script>
		window.onload = function() {
			//创建16*10的网格
			var height = 16;//画布高
			var width = 10;//画布宽
			var gameBox = document.getElementById("game-box");
			var Tab1 = createGrids(height,width);
			Tab1.id = "j-box";
			//创建4*4的网格
			var Tab2 = createGrids(4,4);
			Tab2.id = "next-block";
			gameBox.appendChild(Tab1);
			gameBox.appendChild(Tab2);
			var Trs1 = Tab1.getElementsByTagName("tr");
			var Trs2 = Tab2.getElementsByTagName("tr");
			var block_now,block_next;//当前方块，下一个方块
			var start;//计时器
			var speed = 1000;//方块下落速度(ms)
			var score = 0;//得分
			var rn1,rn2,rm1,rm2;//随机数
			var high;//最高分

			//16*10的方块 方块上一时刻的位置，用于擦除上一秒
			var beforeBlock = new Array();
			for (var i = 0; i < 16; i++) {
				beforeBlock[i] = new Array();
			}

			//16*10的方块 已完成方块
			var allBlock = new Array();
			for (var i = 0; i < 16; i++) {
				allBlock[i] = new Array();
			}

			//16*10的画布
			var ground = new Array();
			for (var i = 0; i < 16; i++) {
				ground[i] = Trs1[i].getElementsByTagName("td");
			}

			//4*4的画布
			var groundNext = new Array();
			for (var i = 0; i < 4; i++) {
				groundNext[i] = Trs2[i].getElementsByTagName("td");
			}



			// 创建网格函数
			function createGrids(row,col) {
				var Tab = document.createElement("table");
				var Tbody = document.createElement("tbody");
				var i = 0;
				while(i<row) {
					var Tr = document.createElement("tr");
					var j = 0;
					while(j<col) {
						var Td = document.createElement("td");
						Tr.appendChild(Td);
						j++;
					}
					Tbody.appendChild(Tr);
					i++;
				}
				Tab.appendChild(Tbody);
				return Tab;
			}









			//------------------方块类--------------------------
			function Block() {
				this.dir = 40;//方块当前移动方向，默认向下。
				this.end = 0;//状态，是否下落完成
				this.shape=new Array();//4*4的方块
				for (var i = 0; i < 4; i++) {
					this.shape[i]=new Array();
				}
				//表示的是方块左上角的初始位置
				/*pos[0]表示方块左上角所在的行，一开始是0，
				pos[1]表示方块左上角所在的列，一开始是3，*/
				this.pos = [0,3];
				this.color = ["#FFAEC9", "#B5E61D", "#99D9EA", "#C8BFE7", "#B97A57"];
			}
			Block.prototype =  {
				//打印方块

				printBlock: function() {
					//判断是否超出边界
					//右
					var q;
					loop1:
					//判断方块里形状的最右侧在第几列
					for (var i  =  3; i >=  0; i--) {
						for(var j = 0;j<4;j++) {
							if(this.shape[j][i]) {
								q = i+1;
								break loop1;
							}
						}
					}
					if(this.pos[1]+q-10 >= 0) {
						this.pos[1] = 10-q;
					}

					//下
					var p;
					loop2:
					//判断方块里形状的最下侧在第几行
					for (var i = 3; i >=0; i++) {
						for (var j = 0; j <4 ; j++) {
							if(this.shape[i][j]) {
								p = i+1;
								break loop2;
							}
						}
					}
					if((this.pos[0]+p)>16) {
						this.end = 1;
						clear(beforeBlock);
	                    return;
					}
					clearBefore();
					//判断左右是否有方块
					for (var i = 0; i < 4; i++) {
						for (var j = 0; j < 4; j++) {
							if(this.shape[i][j]) {
								if($(ground[i + this.pos[0]][j + this.pos[1]]).css("z-index") == "1" && this.dir == 39) {
                                   this.pos[1]--;
                                } else if ($(ground[i + this.pos[0]][j + this.pos[1]]).css("z-index") == "1" && this.dir == 37){
                                    this.pos[1]++;
                                }
							}
						}
					}

					//绘制方块
					for (var i = 0; i < 4; i++) {
						for (var j = 0; j < 4; j++) {
							if(this.shape[i][j]==1) {
								var x = i +this.pos[0];
								var y = i +this.pos[1];
								if(x <15) {
									if($(ground[x+1][y]).css("z-index") == "1") {
										this.end = 1;
									}
								}
								else {
									this.end = 1;
								}
								$(ground[x][y]).css({
									"background":this.color,
									"z-index":1
								});
								beforeBlock[x][y] = 1;
							}
						}
					}


				},

				//顺时针旋转方块90度
				changeBlock: function() {
					//定义了一个二维数组tmp
					var tmp = new Array();
					for(var i = 0;i<4;i++) {
						tmp[i] = new Array();
					}

					//顺时针旋转矩阵90度
					for (var i  =  0,j = 3; i < 4; i++,j--) {
						for (var k  =  0; k <4 ; k++) {
							tmp[k][j] = this.shape[j][i];
						}
					}

					/*再将旋转后的图像移到矩阵左上角
					这样可以表现出在原地旋转的效果*/
					for(var i = 0;i<4;i++) {
						var flag = 1;
						//判断第一列是否有图像
						for(var j = 0;j<4;j++) {
							if(tmp[j][0]) {
								flag = 0;
							}
						}
						//第一列没图像，将第一列移除，并在最后添一列空白
						if(flag) {
							for (var j  =  0; j < 4; j++) {
								tmp[j].shift();
								tmp[j].push(0);
							}
						}
					}

					/*方块旋转完了也移动完了，把新的数组赋值给就得数组
					变相地变换了原数组*/
					for (var i  =  0; i < 4; i++) {
						for (var j  =  0; j < 4; j++) {
							this.shape[i][j] = tmp[i][j];
						}
					}
				},
				//移动方块
				// 左(37) 上(38) 右(39) 下(40)
				moveBlock: function(keyCode) {
					if(!this.end) {//end = 1方块停止
						switch(keyCode) {
							case 38: {
								this.dir = 38;
								this.changeBlock();
								this.printBlock();
								break;
							}
							case 37: {
								this.dir = 37;
								if(this.pos[1]>0) {
									this.pos[1]--;
									this.printBlock();
								}
							}
							case 39: {
								this.dir = 39;
								this.pos[1]++;
								this.printBlock();
								break;
							}
							case 40: {
								this.dir = 40;
								this.goToEnd();
								this.printBlock();
								break();
							}
						}
					}
				},
				//速降
				goToEnd:function() {
					if(!this.end) {
						var l,b,y1;
						//得出方块的右边界
						loop5:
						for (var i = 3; i >= 0; i--) {
							for (var j = 0; j < 4; j++) {
								if(this.shape[j][i]) {
									l=i;//l表示方块的左边界
									break loop5;
								}
							}
						}
						//得出方块的下边界及最下的部分的列数
						loop6:
						for (var i = 3; i >= 0; i--) {
							for (var j = 0; j < 4; j++) {
								if(this.shape[i][j]) {
									b=i;//b表示方块的下边界
									y1=j;//y1表示方块最下的部分的列数
									break loop6;
								}
							}
						}
						var x1=this.pos[1];//方块左边的列数
						var x2=1+this.pos[1];
						var x3=-1;
						var x4;

						loop7:
						//下方有方块时，下方方块最顶的块的行列
						for (var i = 0; i < 16; i++) {
							for (var j = x1; j < = x2; j++) {
								if(allBlock[i][j]) {
									x3=i;
									x2=j;//确定了下方方块最顶块的行列
									break loop7;
								}
							}
						}

						//下方有方块时，上方块最底的块对应下方的块的行列
						for (var i = 0; i < 16; i++) {
							if(allBlock[i][y1+this.pos[1]]) {
								x4=i;//上方块最底的块对应下方的块的行
								break;
							}
							else {
								x4=16;
							}
						}
						//方块下方没有方块时
						if(x3==-1) {
							this.pos[0]=15-b;
							this.end=1;
							return;
						}
						//算出下方最顶方块距离上方块对应位置距离
						for (var i = 3; i >= 0; i--) {
						    if (this.shape[i][x2-this.pos[1]]){
						        x2 = x3 - i-this.pos[0] -1;
						        break;
						    }
						}
						//取较小距离，后者为上方方块最底距离下方对应方块距离
						var x5 = Math.min(x2, (x4-b-1-this.pos[0]))
						// this.pos[0] = x2+this.pos[0];
						// console.log(x4,b,x4-b-1-this.pos[0],x5)
						//将方块移动至该位置
						this.pos[0] = x5+this.pos[0];
						this.end = 1;
					}
				}
			}
			//--------------------------------------
			//--7种形状的方块继承Block----------------
			function Block_i() {
			    Block.call(this);
			    this.shape = [
			        [1, 1, 1, 1],
			        [0, 0, 0, 0],
			        [0, 0, 0, 0],
			        [0, 0, 0, 0]
			    ];
			}
			Block_i.prototype = new Block();
			function Block_s() {
			    Block.call(this);
			    this.shape = [
			        [0, 1, 1, 0],
			        [1, 1, 0, 0],
			        [0, 0, 0, 0],
			        [0, 0, 0, 0]
			    ];
			}
			Block_s.prototype = new Block();
			function Block_j() {
			    Block.call(this);
			    this.shape = [
			        [0, 1, 0, 0],
			        [0, 1, 0, 0],
			        [1, 1, 0, 0],
			        [0, 0, 0, 0]
			    ];
			}
			Block_j.prototype = new Block();
			function Block_o() {
			    Block.call(this);
			    this.shape = [
			        [1, 1, 0, 0],
			        [1, 1, 0, 0],
			        [0, 0, 0, 0],
			        [0, 0, 0, 0]
			    ];
			}
			Block_o.prototype = new Block();
			function Block_z() {
			    Block.call(this);
			    this.shape = [
			        [1, 1, 0, 0],
			        [0, 1, 1, 0],
			        [0, 0, 0, 0],
			        [0, 0, 0, 0]
			    ];
			}
			Block_z.prototype = new Block();
			function Block_t() {
			    Block.call(this);
			    this.shape = [
			        [0, 1, 0, 0],
			        [1, 1, 1, 0],
			        [0, 0, 0, 0],
			        [0, 0, 0, 0]
			    ];
			}
			Block_t.prototype = new Block();
			function Block_l() {
			    Block.call(this);
			    this.shape = [
			        [1, 0, 0, 0],
			        [1, 0, 0, 0],
			        [1, 1, 0, 0],
			        [0, 0, 0, 0]
			    ];
			}
			Block_l.prototype = new Block();
			//------------------------------------------------
			//产生一个方块
			function createBlock(r1, r2) {
			    // var r = 0;
			    switch (r1) {
			        case 0: block_new = new Block_i();break;
			        case 1: block_new = new Block_j();break;
			        case 2: block_new = new Block_l();break;
			        case 3: block_new = new Block_o();break;
			        case 4: block_new = new Block_s();break;
			        case 5: block_new = new Block_t();break;
			        case 6: block_new = new Block_z();break;
			    }
			    block_new.color = block_new.color[r2];
			    return block_new;
			}
			//用于清零16*10的矩阵（beforeBlock和allBlock）
			function clear(clearBlock) {
			    for (var i = 0; i < 16; i++) {
			        for (var j = 0; j < 10; j++) {
			            clearBlock[i][j] = 0;
			        }
			    }
			}
			//擦除上一时刻方块
			function clearBefore() {
			    for (var i = 0; i < 16; i++) {
			        for (var j = 0; j < 10; j++) {
			            if (beforeBlock[i][j]) {
			                $(ground[i][j]).css({"background" : "white", "z-index" : 0});
			                beforeBlock[i][j] = 0;
			            }
			        }
			    }
			}
			window.addEventListener("keydown",function(event) {
				if (36<event.keyCode&&41>event.keyCode) {
					block_now.moveBlock(event.keyCode);
				}
			})
		}
	</script>
</body>
</html>