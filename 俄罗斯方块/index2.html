<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>自己开始写俄罗斯方块</title>
	<link rel="stylesheet" type="text/css" href="index2.css">
</head>
<body>
	<div id="container">
		<div id="display-area"></div>
		<div id="control-area">
			<div id="next">
				<h3 class="next-tit">next:</h3>
			</div>
			<h3 class="score">score：<span id="myscore"></span></h3>
	        <div class="highest">历史最高分：<span id="high"></span></div>
	        <div class="btn">
	            <button id="h-clear" class="clear">清空缓存</button>
	            <button id="restart" class="clear">结束游戏</button><br>
	            <button id="h-stop" class="stop">开始游戏</button>
	        </div>
		</div>
	</div>
	<script>
		(function() {
			// 生成16*10的网格
			(function printGrids1(x,y) {
				var displayArea=$("display-area");
				var Tab=createGrids(x,y);
				Tab.id="grids";
				displayArea.appendChild(Tab);
			})(16,10);
			// 生成4*4的网格
			(function printGrids2(x,y) {
				var Next=$("next");
				var Tab=createGrids(x,y);
				Tab.id="next-block";
				Next.appendChild(Tab);
			})(4,4);
			var block_now;
			var timer//计时器
			var speed=800;//方块下落速度
			var score=0;
			var high=0;
			//用一个二维数组表示绘制的网格
			//16*10的画布
			var aTrs1=$("grids").getElementsByTagName("tr");
			var ground = new Array();
			for (var i = 0; i < 16; i++) {
			    ground[i]=aTrs1[i].getElementsByTagName("td");
			}
			var aTrs2=$("next").getElementsByTagName("tr");
			var groundNext = new Array();
			for (var i = 0; i < 4; i++) {
			    groundNext[i]=aTrs2[i].getElementsByTagName("td");
			}
			var beforeBlock = new Array();//16*10的方块 方块上一时刻的位置，用于擦除上一秒
			for (var i = 0; i < 16; i++) {
			        beforeBlock[i] = new Array();
		    }
		    var allBlock = new Array();//16*10的方块 已完成方块
		    for (var i = 0; i < 16; i++) {
		            allBlock[i] = new Array();
	        }



//-------------------------------------
			//方块类
			//把属性定义到方块对象上
			function Block() {
				this.dir=40;
				this.end=0;
				//方块左上角网格的位置,相当于方块的原点
				this.pos=[0,3];
				this.color=["#F53636","#3A65FC","#2DFBAA","#E0FC26"];
			}
			//把方法定义到方块对象的原型上
			Block.prototype= {
				//打印方块
				printBlock:function() {
					//先清除之前的方块
					//然后判断是否超出边界
					//右
					var q;
					loop1:
					for (var i = 3; i >= 0; i--) {
					    for (var j = 0; j < 4; j++) {
					        if (this.shape[j][i]) {
					            q = i+1;
					            break loop1;
					        }
					    }
					}
					if ((this.pos[1]+q-10) >= 0) {
					    this.pos[1] = 10-q;
					}
					//判断下边界
					var p;
					loop1:
					for (var i = 3; i >= 0; i--) {
						for (var j = 0; j < 4; j++) {
							if(this.shape[i][j]) {
								p = i;//方块的下边界所在的行数
								break loop1;
							}
						}
					}
					if(this.pos[0]+p>=16) {
						this.end=1;
						// clear(beforeBlock);
						// return;
					}
					clearBefore();
					//判断左右是否有方块
					for (var i = 0; i < 4; i++) {
					    for (var j = 0; j < 4; j++) {
					        if(this.shape[i][j] == 1){
					            if (ground[i + this.pos[0]][j + this.pos[1]].style.zIndex== "1" && this.dir == 39) {
					                   this.pos[1]--;
					                } else if (ground[i + this.pos[0]][j + this.pos[1]].style.zIndex== "1" && this.dir == 37){
					                    this.pos[1]++;
					                }
					        }
					    }
					}
					//再绘制
					//你就只管绘制，到底有没有接触其他方块交给this.end吧
					for (var i = 0; i < 4; i++) {
						for (var j = 0; j < 4; j++) {
							if (this.shape[i][j]) {
								var x=i+this.pos[0];
								var y=j+this.pos[1];
								if (x<15) {
									if(ground[x+1][y].style.zIndex==1) {
										this.end=1;
									}
								}
								else {
									this.end=1;
								}
								ground[x][y].style.backgroundColor=this.color;
								ground[x][y].style.zIndex=1;
								beforeBlock[x][y]=1;//复制一份
							}
						}
					}
					//若方块下落完毕，将方块加入到已下落方块矩阵中
					if(this.end==1) {
						for (var i = 0; i < 4; i++) {
							for (var j = 0; j < 4; j++) {
								if (this.shape[i][j]) {
									allBlock[i + this.pos[0]][j + this.pos[1]] = 1;
								}
							}
						}
					}
				},
				//顺时针旋转90度
				changeBlock:function() {
					var tmp=new Array();
					for (var i = 0; i < 4; i++) {
						tmp[i]=new Array();
					}
					//顺时针旋转90度
					for (var i = 0,j=3; i < 4; i++,j--) {
						for (var k = 0; k < 4; k++) {
							tmp[i][k]=this.shape[k][j];
						}
					}
					//将旋转后的图像移到矩阵左上角
					for(var i=0;i<4;i++) {
						var flag=1;
						for (var j = 0; j < 4; j++) {
							if(tmp[j][0]) {
								flag=0;
							}
						}
						if(flag) {
							for (var i = 0; i < 4; i++) {
								tmp[i].shift();//删除空白首列
								tmp[i].push(0);//在后面加 0
							}
						}
					}
					//将旋转后的矩阵保存回原来的矩阵
					for(var i = 0;i < 4;i++) {
						for(var j = 0;j < 4;j++) {
							this.shape[i][j] = tmp[i][j];
						}
					}
				},
				//移动方块
				// 左(37) 上(38) 右(39) 下(40)
				moveBlock:function(keyCode) {
					//如果没有触底
					if(!this.end) {
						switch(keyCode) {
							case 38: {
								this.dir = 38;
	                            this.changeBlock();
	                            this.printBlock();
	                            break;
							}
							case 37: {
								this.dir=37;
								if(this.pos[1]>0) {
									this.pos[1]--;
									this.printBlock();
								}
								break;
							}
							case 39: {
								this.dir = 39;
								this.pos[1]++;
								this.printBlock();
								break;
							}
							case 40: {
								this.dir = 40;
	                            this.goToEnd();
	                            this.printBlock();
	                            break;
							}
						}
					}
				},
				//速降
				goToEnd : function(){
				    if (!this.end) {
				        var l,b,y1;
				        //得出方块的右边界
				        loop5:
				        for (var i = 3; i >= 0; i--) {
				            for (var j = 0; j < 4; j++) {
				                if (this.shape[j][i]) {
				                    l = i;
				                    break loop5;
				                }
				            }
				        }
				        //得出方块的下边界及最下的部分的列数
				        loop6:
				        for (var i = 3; i >= 0; i--) {
				            for (var j = 0; j < 4; j++) {
				                if (this.shape[i][j]) {
				                    b = i;
				                    y1 = j;
				                    break loop6;
				                }
				            }
				        }
				        var x1 = this.pos[1];
				        var x2 = l + this.pos[1];
				        var x3 = -1;
				        var x4;
				        // test();
				        loop7:
				        //下方有方块时，下方方块最顶的块的行列
				        for (var i = 0; i < 16; i++) {
				            for (var j = x1; j <= x2; j++) {
				                if (allBlock[i][j]) {
				                    x3 = i;//第几行已有方块
				                    x2 = j;
				                    break loop7;
				                }
				            }
				        }
				        //下方有方块时，上方块最底的块对应下方的块的行列
				        for (var i = 0; i < 16; i++) {
				            if (allBlock[i][y1+this.pos[1]]) {
				                x4 = i;
				                break;
				            } else {
				                x4 = 16;
				             }
				        }
				        console.log("y1:"+y1,"x4:"+x4,"b:"+b,this.pos[0],this.pos[1])
				        //方块下方没有方块时
				        if (x3 == -1) {
				            this.pos[0] = 15 - b;
				            this.end = 1;
				            return;
				        }
				        //算出下方最顶方块距离上方块对应位置距离
				        for (var i = 3; i >= 0; i--) {
				            if (this.shape[i][x2-this.pos[1]]){
				                x2 = x3 - i-this.pos[0] -1;
				                break;
				            }
				        }
				        //取较小距离，后者为上方方块最底距离下方对应方块距离
				        var x5 = Math.min(x2, (x4-b-1-this.pos[0]))
				        // this.pos[0] = x2+this.pos[0];
				        // console.log(x4,b,x4-b-1-this.pos[0],x5)
				        //将方块移动至该位置
				        this.pos[0] = x5+this.pos[0];
				        this.end = 1;
				    }
				}
			}
			//定义7种类型的方块并继承Block
			function Block_i() {
				Block.call(this);
				this.shape=[
					[1,1,1,1],
					[0,0,0,0],
					[0,0,0,0],
					[0,0,0,0]
				];
			}
			Block_i.prototype = new Block();
			function Block_s() {
				Block.call(this);
				this.shape=[
					[0,1,1,0],
					[1,1,0,0],
					[0,0,0,0],
					[0,0,0,0]
				];
			}
			Block_s.prototype = new Block();
			function Block_j() {
				Block.call(this);
				this.shape=[
					[0,1,0,0],
					[0,1,0,0],
					[1,1,0,0],
					[0,0,0,0]
				];
			}
			Block_j.prototype = new Block();
			function Block_o() {
				Block.call(this);
				this.shape=[
					[0,1,1,0],
					[0,1,1,0],
					[0,0,0,0],
					[0,0,0,0]
				];
			}
			Block_o.prototype = new Block();
			function Block_z() {
				Block.call(this);
				this.shape=[
					[1,1,0,0],
					[0,1,1,0],
					[0,0,0,0],
					[0,0,0,0]
				];
			}
			Block_z.prototype = new Block();
			function Block_t() {
				Block.call(this);
				this.shape=[
					[1,1,1,0],
					[0,1,0,0],
					[0,0,0,0],
					[0,0,0,0]
				];
			}
			Block_t.prototype = new Block();
			function Block_l() {
				Block.call(this);
				this.shape=[
					[0,1,0,0],
					[0,1,0,0],
					[0,1,1,0],
					[0,0,0,0]
				];
			}
			Block_l.prototype = new Block();

			//主程序
			function play() {
				clear(beforeBlock);
				block_now=createBlock();
				block_now.printBlock();
				timer=setInterval(function() {
					block_now.printBlock();
					if(block_now.end) {
						clearInterval(timer);
						if (block_now.pos[0] == 1) {
	                        alert("Game Over !!");
	                        location.reload();
	                    }
	                    else {
	                        play();
	                    }
					}
					getScore()
					// alert(block_now.pos[0]);
					block_now.pos[0]++;
				},speed);
			}


			//---------------------------事件绑定------------------------------
			window.addEventListener("keydown",function() {
				block_now.moveBlock(event.keyCode);
			})
			$("h-stop").addEventListener("click",function() {
				if($("h-stop").innerHTML=="开始游戏") {
					// init();
					play();
					$("h-stop").innerHTML=="暂停";
				}
				else if($("h-stop").innerHTML=="暂停") {
					clearInterval(timer);
					$("h-stop").innerHTML=="开始游戏";
				}
			});
			//随机产生一个方块
			function createBlock() {//r1是下面产生的0~6的随机数
				var block_new;
				var r1=Math.round(Math.random()*6);
				var r2=Math.round(Math.random()*3);
				switch(r1) {
					case 0 :block_new=new Block_i();break;
					case 1 :block_new=new Block_j();break;
					case 2 :block_new=new Block_l();break;
					case 3 :block_new=new Block_o();break;
					case 4 :block_new=new Block_s();break;
					case 5 :block_new=new Block_t();break;
					case 6 :block_new=new Block_z();break;
				}
				block_new.color=block_new.color[r2];
				return block_new;
			}
			//擦除上一时刻方块
			//ground的已经被beforeBlock复制了
			function clearBefore() {
			    for (var i = 0; i < 16; i++) {
			        for (var j = 0; j < 10; j++) {
			            if (beforeBlock[i][j]) {
			                ground[i][j].style.backgroundColor="white";
			                ground[i][j].style.zIndex=0;
			                beforeBlock[i][j] = 0;
			            }
			        }
			    }
			}
			//用于清零16*10的矩阵（beforeBlock和allBlock）
			function clear(clearBlock) {
			    for (var i = 0; i < 16; i++) {
			        for (var j = 0; j < 10; j++) {
			            clearBlock[i][j] = 0;
			        }
			    }
			}
			//得到分数，并判断是否为历史最高分并写入缓存
			function getScore() {
			    var s;
			    for (var i = 0; i < 16; i++) {
			        s = 0;
			        for (var j = 0; j < 10; j++) {
			            if (allBlock[i][j]) {
			                s++;
			            }
			        }
			        if (s == 10) {
			            score = score+1;
			            allBlock.splice(i, 1);
			            allBlock.unshift([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
			            clearBefore();
			            for (var k = i; k > 0; k--) {
			                for (var l = 0; l < 10; l++) {
			                    ground[k][l].style.backgroundColor=ground[k-1][l].style.backgroundColor;
			                    ground[k][l].style.zIndex=ground[k-1][l].zIndex;
			                }
			            }
			        }
			    }
			    var myScore=$("myscore");
			    myScore.innerHTML=score;
			    if (high < score) {
			        high = score;
			        $(high).innerHTML=high;
			    }
			}
//-------------------工具函数--------------------------------
			//定义$()函数
			function $(ele) {
				return document.getElementById(ele);
			}

			//产生指定行列的函数
			function createGrids(row,col) {
				var Tab=document.createElement("table");
				var Tbody=document.createElement("tbody");
				for (var i = 0; i < row; i++) {
					var Trs=document.createElement("tr");
					for (var j = 0; j < col; j++) {
						 var Tds=document.createElement("td");
						 Trs.appendChild(Tds);
					}
					Tbody.appendChild(Trs);
				}
				Tab.appendChild(Tbody);
				return Tab;
			}




















		})();
	</script>
</body>
</html>